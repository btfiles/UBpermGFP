function [aDistribution, bDistribution] = ...
    wsPermutationGFP(aData, bData, nPerm)
%Constructs a GFP permutation distribution for a within-subject permutation
%test. 
%
%[aDistribution, bDistribution] = wsPermutationGFP(aData,bData,nPerm)
%
% INPUTS
% aData, bData are 3-dimensional data matrices containing EEG data for one
% subject in two conditions. Following the EEGLAB convention, matrices are
% M by N by K, for M channels, N samples per trial and K trials. Both
% matrices must have identical sizes on dimensions 1 and 2.  Only dimension
% 3 may be different. These data are assumed to have been average
% referenced.
%
% nPerm is the number of permutations to do. Various guidelines are
% available, but this should be a pretty big number (2000 is a good choice
% for many purposes).
%
% OUTPUTS
% aDistribution and bDistribution are 2-dimensional matrices both of size N
% by nPerm.  Each row of the distribution is the result of computing mGFP
% on a surrogate data matrix.  Surrogate data matrices are generated by
% randomly reshuffling the labels on aData and bData (i.e. by reassigning
% entries in a and b while respecting the respective number of entries).
%
%see also unbalancedPermutationGFP wsPermPvalGFP

% validate a/bData
aSz = size(aData);
bSz = size(bData);
assert(length(aSz)==3,'Input argument aData must have 3 dimensions.');
assert(length(bSz)==3,'Input argument bData must have 3 dimensions.');
assert(all(aSz(1:2)==bSz(1:2)),['Input arguments aData and bData must', ...
    ' have the same size for all but the last dimension.']);

% validate nPerm
assert(round(nPerm)==nPerm && nPerm > 1,['Input argument nPerm must ', ...
    'evaluate to an integer greater than one.']);

if nPerm < 100,
    warning('UBGFP:LowPerm', ['The requested number of permutations, ', ...
        '%d, is very low. This is fine for debugging, but consider ', ...
        'a larger value for doing anything real.'], nPerm);
end

% compute mgfp on original data
aGfp = mgfp(aData);
bGfp = mgfp(bData);

% initialize the output arguments
aDistribution = zeros([size(aGfp) nPerm]);
bDistribution = zeros([size(bGfp) nPerm]);

% prepare for permutations
d = cat(3, aData, bData); 
lbl = false(size(d,3),1);
lbl(1:size(aData,3)) = true; %could clear aData, bData at this point.

% Set the first entry of the distribution equal to the 'true' value.  This
% avoids bias when randomly selecting permutations.
aDistribution(:,1) = aGfp;
bDistribution(:,1) = bGfp;

% I considered parallellizing this loop, but the overhead is probably not
% worth it.
for iPerm = 2:nPerm,
    pLbl = lbl(randperm(length(lbl))); % shuffle the labels
    aDistribution(:,iPerm) = mgfp(d(:, :, pLbl));
    bDistribution(:,iPerm) = mgfp(d(:, :, ~pLbl));
end
end % End of wsPermutationGFP

% Helper function
function g = mgfp(d)
% Compute global field power of mean ERP
% input d is M by N by K, output g is 1 by N.
g = sqrt(mean( mean(d, 3).^2, 1))';
% less readable, but faster, would be to leave gfp squared and do one
% square root on the entire distribution matrix.
end

% Change Log
%   2015-12-04 Initial Release - BTF

% Copyright notice
%    Copyright 2015 Benjamin T. Files
% 
%    Licensed under the Apache License, Version 2.0 (the "License");
%    you may not use this file except in compliance with the License.
%    You may obtain a copy of the License at
% 
%        http://www.apache.org/licenses/LICENSE-2.0
% 
%    Unless required by applicable law or agreed to in writing, software
%    distributed under the License is distributed on an "AS IS" BASIS,
%    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
%    implied. See the License for the specific language governing
%    permissions and limitations under the License.